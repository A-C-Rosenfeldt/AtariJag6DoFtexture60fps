
Clipping to viewport and portals and to merge BSP needs a division.
On the Jag with fast MUL we might want to use fraction also for compare.
Sometimes we get to close to zero. One code path would be to pull in more precision on demand:
But we had to round the factors to 16 bit. Now we need to MAC  ( AL * BH ) + ( AH * BL ) for the next 16 bit.
Highest precision max once a frame?
I think I calculated that I need three factors.
If I want planar bsp without triangulation, I also have the rotation multiplication.
I don't know how to do floats here. I want to translate and the float.
Hopefully the same exponents enter all products in the MAC.

We have to transit to pixel some time.
Due to the planned const-z shader I hesitate to use scanlines nor kd-trees.
Anyway, a polygon becomes smaller and may only cover on of our const-z directions:
horizontal, vertical, both diagonales.
Then we need to get the extreme pixels which are still covered.

A small polygon may even fall throught the cracks between the pixel centers.

When the cut between three edges as area to close to 0 with 16bit = 65000 subpixels on SD screen
of 320 px we have a high chance to be away from a pixel center after DIV.
The Jag has a config register to set options of div to get useful, large, numbers, even
32 bit maybe ( fixed point ) .. so sounds attractive.

So we don't know the order of cuts on the vertex on comparison.
We have a tree, but some edges appear as ghost in other nodes. Just add an attribute for this
linked list of ghosts in the corners.
We just use the rounded value to determine the color for the pixel.

We need to keep the straights straight.
When we merge two BSP, we need to be able to trust the comparison with parent splits.
Those splits are not allowed to be curved or tesselated in an uncontrolled way.
We know the ghosts and copy them into the result. What do we do with them?


Lets say I have a convex polygon in our BSPt and want to split it further.
Around we have a ring of : edge, vertex, edge, vertex
Additionally there can be ghosts in the vertices.
Theoretically I could have nearly parallel lines and thus ghost on an edge.
Now the split may stay clear of the vertices and the ghost ends up in only one of the children.
Otherwise the ghost can be in both. So many references to one ghost-creator.
I don't think that the ghost creator is interested in its ghosts.

#Comparison with Doom coverage buffer
Using the edge equations avoid strange jitter like the coverage buffer in Doom.
Even the comments in the visiPlane code mention that it only works well due to the fact that edges filled the coverage buffer .. and not sprites with transparency for example.

#flat polygons for architecture and machines

BSP in the scenery are described by a triangle with computed solid geometry after camera rotation.
One would think that this gives us complicted vertices,
but the BeamTree is concerned more with edges.
Edges between planes .. even more multiplications.


#B-Tree

Our Memory container is of course our beloved b-Tree. So I store the binary tree in an n-tree with
a tuned size. Over that size, b-tree nodes split. Below they merge.
A node will first compact itself following the binary tree structure in it.
We don't have sectors in RAM and pages are not well known. So nodes are not usually aligned.
They can grow to both sides until they collide with other nodes.
Then the larger node will split.
With large free regions ( I keep a sorted list ), I may want to pull in nodes from the outside,
so that they better match their position in the tree.

#Demo SceneGraph
I could use spheres, but I have trouble to use them for LoD. Somehow they introduce squared surfaces and cones.
So I could create a random tree with convex leafs ( asteroid field) and just aggregate by proxity.
The bounding volume is composed of all the faces which don't see the siblings and then
the closest two vertices of from different siblings are connected, then the next, until the volume in between is triangulized.
Inflate until nothing sticks out and the shape is convex. Simplify small faces and angles.

Splitting
Sort by longest, prefer who does not split others. I would guess that there is a natural order comming from our trees.
So we look down the tree and do a red-black tree kind of rotation to promote better splits. It is a bit like a chess game: pertube all the splits.
Thus it may make sense to run these on Jerry: Like in a chess game it tries multiple splits and then procedes with the tree.
If according to some heuristics, too many splits happen, Jerry rotates the top tree and again tries to build a BSP. 
Meanwhile, Tom goes into the depth of the tree.
The tree naturally has leaf nodes, but we may want to rasterize before we get there if the area of a node is small enough .. max width small and number of edges per scanline small.
Then we go by scanline and use the tree to pull the active nodes and sort the edges by x.
Like the floor in Doom this allows us to run the texture over all splits.
It even makes sense to instead use 8px regular splits on those spans for perspective corretion.
Feels like we should be greedy to find the complete uninterrupted span of the polygon and walk the tree for this, if necessary.
So we go down the nodes in the BSP tree and when the number of edges per scanline fits into the registers, we switch to scanline.
And we could try to add nodes (siblings or their children) into those scanline where we don't reach the limit.
Yeah maybe an extra code path for short subspans is useful: Every pixel is perspective correct and we use the blitter only to StoreP.
To have a simple shader state, texture caching makes sense. All visible mipmap levels are decompressed (multi-texture) and lit on demand.

transition to pixels

ensure a blitter span stays clear
	of
		real edges on screen
		seams in the texture atlas

For concave node on screen I could rasterize all edges using a spanline renderer.
For a concave leaf I need to sort vertics by y anyway.
maybe I can check if edges cross between vertex.y ? Hmm.
I don't want unecessary splits of the blitter run ( perspective wants them, but hey ), thus split by scanline and then the edges are only used to check
if the current span is still on top. Kinda like the merge of Doom floors.

The other way may be that the beam tree is too lazy to check for high precision in case no pixel is nearby. This may cut down on the real expensive MUL, the tail.

The typical problem will be that we have a beam tree with vertice which are no real vertices, but crossings.
Now we could check between which scanlines these cross.
If the crossing is far away from the lines, I can detect that ("worst case"(+some if you don't trust your code)).
It is still statistical. Makes not sense to do infi precision here?
Breadth first search? Try to isolate cases 3 edges and 2 edge+scanline whoever comes clear first?
I miss the synergy with rasterization. I mean, I need to isolate scanlines relative to real vertices, yeah but also for crossings.
Otherwise I need to raytrace. Rays to crossing ?? Rays can only shot left or right around an edge.
Rays can be rounded. Hence for small polygons raytracing on CPU may win.
Blitter spans don't follow naturally.
About synergy: if I start rasterizing corners of a polygon ( node ),
These scanline become the beam tree splits. Further down trees are spli into upper and lower part.
Make sure that there are not so may nodes below this ( small subtrees ) to avoid exessive splits.
Also frame to frame coherence only works with a beam tree.

When there is a group of faces all facing the camera then there is no occlusion.
I want a unified approach for LoD and perspective correction and lightning which recognizes the importance of the normal of a face.
Almost faces, aka organic, smooth surface should profit from this also.
Linear inter polation in the blitter still has to recognize the boundaries.
So I have a given beam tree from another node in the BSP which may contain occludions for this node.
But I don't use this node to split internally.

Maybe I can use this group apporach for all meshes. When I know that max 16 polygons overlap on a single scan line,
I can use scanline rendering to solve occlusion.
Rounding is allowed as long as I don't touch real boundaries of the BSP.
Of course, with gaps, I have a problem. So I need a "watertight" flag, which still depends on a normal or portals. I guess I can have portals in a BSP-tree.
Overall, this feels like it needs more code and not like common sense to allow rounding.
May still be interesting for dead end caves behind a simple portal (interface of a parent BSP node), just to show that there is no road-block.

Another way would be to do raytracing on a low number of polygons. The ray position can be rounded to world space.
This may be needed for some cases: Enemies far away . Plants. When I don't want to do LoD.


##rasterization and fusion of spans for the blitter

I need to find the relevant scanlines.
for each scan line I try to set a blitter line on the screen ( longest possible span and I may even be allowed to round the ray directions in world space),
but also in the projected space on the texture atlas with the given rounding in the blitter registers.
Anyway, I need 2 paases:
1) create beam tree from BSP
2) go over all touched polygons (to undo any splits due to BSP or beamtree)

3) subspan perspective correction with dynamic width because loop unrolling has no advange with the blitter.
		Sadly, the blitter isn't suited for 8x8 tiles. 
